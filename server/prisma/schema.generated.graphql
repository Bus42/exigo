### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

scalar DateTime

type MultipleOptionsQuizItemFragment {
  constraints_maxCount: Int
  constraints_minCount: Int
  id: ID!
  options(after: ID, before: ID, first: Int, last: Int, skip: Int): [Option!]!
  quizItem: QuizItem!
}

input MultipleOptionsQuizItemFragmentCreateOneWithoutFragmentMultipleOptionsInput {
  connect: MultipleOptionsQuizItemFragmentWhereUniqueInput
  create: MultipleOptionsQuizItemFragmentCreateWithoutQuizItemInput
}

input MultipleOptionsQuizItemFragmentCreateWithoutQuizItemInput {
  constraints_maxCount: Int
  constraints_minCount: Int
  id: ID
  options: OptionCreateManyWithoutOptionsInput
}

input MultipleOptionsQuizItemFragmentUpdateOneWithoutQuizItemInput {
  connect: MultipleOptionsQuizItemFragmentWhereUniqueInput
  create: MultipleOptionsQuizItemFragmentCreateWithoutQuizItemInput
  delete: Boolean
  disconnect: Boolean
  update: MultipleOptionsQuizItemFragmentUpdateWithoutQuizItemDataInput
  upsert: MultipleOptionsQuizItemFragmentUpsertWithoutQuizItemInput
}

input MultipleOptionsQuizItemFragmentUpdateWithoutQuizItemDataInput {
  constraints_maxCount: Int
  constraints_minCount: Int
  id: ID
  options: OptionUpdateManyWithoutMultipleOptionsQuizItemFragmentInput
}

input MultipleOptionsQuizItemFragmentUpsertWithoutQuizItemInput {
  create: MultipleOptionsQuizItemFragmentCreateWithoutQuizItemInput!
  update: MultipleOptionsQuizItemFragmentUpdateWithoutQuizItemDataInput!
}

input MultipleOptionsQuizItemFragmentWhereUniqueInput {
  id: ID
}

type Mutation {
  createOneQuiz(data: QuizCreateInput!): Quiz!
  createOneUser(email: String, password: String): User!
  deleteOneQuiz(where: QuizWhereUniqueInput!): Quiz
  updateOneQuiz(data: QuizUpdateInput!, where: QuizWhereUniqueInput!): Quiz
}

type NumericQuizItemFragment {
  constraints_maxValue: Float
  constraints_minValue: Float
  id: ID!
  precision: Float
  quizItem: QuizItem!
  solution: Float!
  stepSize: Float
}

input NumericQuizItemFragmentCreateOneWithoutFragmentNumericInput {
  connect: NumericQuizItemFragmentWhereUniqueInput
  create: NumericQuizItemFragmentCreateWithoutQuizItemInput
}

input NumericQuizItemFragmentCreateWithoutQuizItemInput {
  constraints_maxValue: Float
  constraints_minValue: Float
  id: ID
  precision: Float
  solution: Float!
  stepSize: Float
}

input NumericQuizItemFragmentUpdateOneWithoutQuizItemInput {
  connect: NumericQuizItemFragmentWhereUniqueInput
  create: NumericQuizItemFragmentCreateWithoutQuizItemInput
  delete: Boolean
  disconnect: Boolean
  update: NumericQuizItemFragmentUpdateWithoutQuizItemDataInput
  upsert: NumericQuizItemFragmentUpsertWithoutQuizItemInput
}

input NumericQuizItemFragmentUpdateWithoutQuizItemDataInput {
  constraints_maxValue: Float
  constraints_minValue: Float
  id: ID
  precision: Float
  solution: Float
  stepSize: Float
}

input NumericQuizItemFragmentUpsertWithoutQuizItemInput {
  create: NumericQuizItemFragmentCreateWithoutQuizItemInput!
  update: NumericQuizItemFragmentUpdateWithoutQuizItemDataInput!
}

input NumericQuizItemFragmentWhereUniqueInput {
  id: ID
}

type Option {
  id: ID!
  isSolution: Boolean!
  text: String!
}

input OptionCreateManyWithoutOptionsInput {
  connect: [OptionWhereUniqueInput!]
  create: [OptionCreateWithoutMultipleOptionsQuizItemFragmentInput!]
}

input OptionCreateWithoutMultipleOptionsQuizItemFragmentInput {
  id: ID
  isSolution: Boolean
  text: String!
}

input OptionScalarWhereInput {
  AND: [OptionScalarWhereInput!]
  id: StringFilter
  isSolution: BooleanFilter
  NOT: [OptionScalarWhereInput!]
  OR: [OptionScalarWhereInput!]
  text: StringFilter
}

input OptionUpdateManyDataInput {
  id: ID
  isSolution: Boolean
  text: String
}

input OptionUpdateManyWithoutMultipleOptionsQuizItemFragmentInput {
  connect: [OptionWhereUniqueInput!]
  create: [OptionCreateWithoutMultipleOptionsQuizItemFragmentInput!]
  delete: [OptionWhereUniqueInput!]
  deleteMany: [OptionScalarWhereInput!]
  disconnect: [OptionWhereUniqueInput!]
  set: [OptionWhereUniqueInput!]
  update: [OptionUpdateWithWhereUniqueWithoutMultipleOptionsQuizItemFragmentInput!]
  updateMany: [OptionUpdateManyWithWhereNestedInput!]
  upsert: [OptionUpsertWithWhereUniqueWithoutMultipleOptionsQuizItemFragmentInput!]
}

input OptionUpdateManyWithWhereNestedInput {
  data: OptionUpdateManyDataInput!
  where: OptionScalarWhereInput!
}

input OptionUpdateWithoutMultipleOptionsQuizItemFragmentDataInput {
  id: ID
  isSolution: Boolean
  text: String
}

input OptionUpdateWithWhereUniqueWithoutMultipleOptionsQuizItemFragmentInput {
  data: OptionUpdateWithoutMultipleOptionsQuizItemFragmentDataInput!
  where: OptionWhereUniqueInput!
}

input OptionUpsertWithWhereUniqueWithoutMultipleOptionsQuizItemFragmentInput {
  create: OptionCreateWithoutMultipleOptionsQuizItemFragmentInput!
  update: OptionUpdateWithoutMultipleOptionsQuizItemFragmentDataInput!
  where: OptionWhereUniqueInput!
}

input OptionWhereUniqueInput {
  id: ID
}

type Query {
  quizzes(after: ID, before: ID, first: Int, last: Int, skip: Int): [Quiz!]!
}

type Quiz {
  author: User!
  createdAt: DateTime!
  id: ID!
  isPrivate: Boolean!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [QuizItem!]!
  timeLimitInMinutes: Int
  title: String!
  updatedAt: DateTime!
}

input QuizCreateInput {
  author: UserCreateOneWithoutAuthorInput!
  createdAt: DateTime
  id: ID
  isPrivate: Boolean
  items: QuizItemCreateManyWithoutItemsInput
  timeLimitInMinutes: Int
  title: String!
  updatedAt: DateTime
}

type QuizItem {
  fragmentMultipleOptions: MultipleOptionsQuizItemFragment
  fragmentNumeric: NumericQuizItemFragment
  id: ID!
  quiz: Quiz!
  stem: String!
  type: QuizItemType!
}

input QuizItemCreateManyWithoutItemsInput {
  connect: [QuizItemWhereUniqueInput!]
  create: [QuizItemCreateWithoutQuizInput!]
}

input QuizItemCreateWithoutQuizInput {
  fragmentMultipleOptions: MultipleOptionsQuizItemFragmentCreateOneWithoutFragmentMultipleOptionsInput
  fragmentNumeric: NumericQuizItemFragmentCreateOneWithoutFragmentNumericInput
  id: ID
  stem: String!
  type: QuizItemType!
}

input QuizItemScalarWhereInput {
  AND: [QuizItemScalarWhereInput!]
  id: StringFilter
  NOT: [QuizItemScalarWhereInput!]
  OR: [QuizItemScalarWhereInput!]
  stem: StringFilter
  type: QuizItemType
}

enum QuizItemType {
  MULTIPLE_OPTIONS
  NUMERIC
}

input QuizItemUpdateManyDataInput {
  id: ID
  stem: String
  type: QuizItemType
}

input QuizItemUpdateManyWithoutQuizInput {
  connect: [QuizItemWhereUniqueInput!]
  create: [QuizItemCreateWithoutQuizInput!]
  delete: [QuizItemWhereUniqueInput!]
  deleteMany: [QuizItemScalarWhereInput!]
  disconnect: [QuizItemWhereUniqueInput!]
  set: [QuizItemWhereUniqueInput!]
  update: [QuizItemUpdateWithWhereUniqueWithoutQuizInput!]
  updateMany: [QuizItemUpdateManyWithWhereNestedInput!]
  upsert: [QuizItemUpsertWithWhereUniqueWithoutQuizInput!]
}

input QuizItemUpdateManyWithWhereNestedInput {
  data: QuizItemUpdateManyDataInput!
  where: QuizItemScalarWhereInput!
}

input QuizItemUpdateWithoutQuizDataInput {
  fragmentMultipleOptions: MultipleOptionsQuizItemFragmentUpdateOneWithoutQuizItemInput
  fragmentNumeric: NumericQuizItemFragmentUpdateOneWithoutQuizItemInput
  id: ID
  stem: String
  type: QuizItemType
}

input QuizItemUpdateWithWhereUniqueWithoutQuizInput {
  data: QuizItemUpdateWithoutQuizDataInput!
  where: QuizItemWhereUniqueInput!
}

input QuizItemUpsertWithWhereUniqueWithoutQuizInput {
  create: QuizItemCreateWithoutQuizInput!
  update: QuizItemUpdateWithoutQuizDataInput!
  where: QuizItemWhereUniqueInput!
}

input QuizItemWhereUniqueInput {
  id: ID
}

input QuizUpdateInput {
  author: UserUpdateOneRequiredWithoutQuizzesInput
  createdAt: DateTime
  id: ID
  isPrivate: Boolean
  items: QuizItemUpdateManyWithoutQuizInput
  timeLimitInMinutes: Int
  title: String
  updatedAt: DateTime
}

input QuizWhereUniqueInput {
  id: ID
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  createdAt: DateTime!
  email: String!
  id: ID!
  quizzes(after: ID, before: ID, first: Int, last: Int, skip: Int): [Quiz!]!
}

input UserCreateOneWithoutAuthorInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuizzesInput
}

input UserCreateWithoutQuizzesInput {
  createdAt: DateTime
  email: String!
  id: ID
  name: String
  passwordHash: String!
}

input UserUpdateOneRequiredWithoutQuizzesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuizzesInput
  update: UserUpdateWithoutQuizzesDataInput
  upsert: UserUpsertWithoutQuizzesInput
}

input UserUpdateWithoutQuizzesDataInput {
  createdAt: DateTime
  email: String
  id: ID
  name: String
  passwordHash: String
}

input UserUpsertWithoutQuizzesInput {
  create: UserCreateWithoutQuizzesInput!
  update: UserUpdateWithoutQuizzesDataInput!
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
